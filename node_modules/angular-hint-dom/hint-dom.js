'use strict';

/**
* Create an interceptor that will log a message when use of a DOM API is detected
*/
var domInterceptor = require('dom-interceptor');
domInterceptor.enableLineNumbers(3);
var hintLog = angular.hint = require('angular-hint-log');
var INTERCEPTOR_FUNCTION = function(message) {
  var moduleName = 'DOM',
    severityWarning = 2;
  hintLog.logMessage(moduleName, message, severityWarning);
};

/**
* Decorates $controller with a patching function to
* throw an error if DOM APIs are manipulated from
* within an Angular controller
*/
angular.module('ngHintDom', []).
  config(function ($provide) {
    $provide.decorator('$controller', function($delegate, $injector) {

      var patchedServices = {},
        patchedDependencies = {},
        patchedFunctions = {};

      return function(ctrl, locals) {

        //If this controller is the NgModelController created by Angular
        //There is no need to detect its manipulation of the DOM
        if(ctrl.toString().indexOf('@name ngModel.NgModelController#$render') > -1 ||
            ctrl.toString().indexOf('@name form.FormController') > -1) {
          return $delegate.apply(this, [ctrl, locals]);
        }

        //If the controller method is given only the controller's name,
        //find the matching controller method from the controller list
        if(typeof ctrl === 'string') {
          ctrl = nameToConstructorMappings[ctrl] || window[ctrl] || ctrl;
          if(typeof ctrl === 'string') {
            throw new Error('The controller function for ' + ctrl + ' could not be found.' +
              ' Is the function registered under that name?');
          }
        }

        var dependencies = $injector.annotate(ctrl);

        // patch methods on $scope
        locals = locals || {};
        dependencies.forEach(function (dep) {
          if (typeof dep === 'string' && !locals[dep]) {
            if(dep === '$http') {
              locals[dep] = $injector.get(dep);
            } else {
            locals[dep] = patchedServices[dep] ||
              (patchedServices[dep] = patchService($injector.get(dep)));
            }
          }
        });


        function disallowedContext(fn) {
          return function () {
            domInterceptor.addManipulationListener(INTERCEPTOR_FUNCTION);
            var ret = fn.apply(this, arguments);
            domInterceptor.removeManipulationListener();
            return ret;
          };
        }

        function patchArguments (fn) {
          return function () {
            for (var i = 0, ii = arguments.length; i < ii; i++) {
              if (typeof arguments[i] === 'function') {
                arguments[i] = disallowedContext(arguments[i]);
              }
            }
            return fn.apply(this, arguments);
          };
        }

        function patchService (obj) {
          if (typeof obj === 'function') {
            return patchArguments(obj);
          } else if (obj !== null && typeof obj === 'object') {
            return Object.keys(obj).reduce(function (obj, prop) {
              if(obj instanceof Element) {
                return obj[prop];
              }
              if(patchedDependencies[obj[prop]]) {
                return obj[prop], obj;
              }
              patchedDependencies[obj[prop]] = obj[prop];

              try {
                return obj[prop] = patchService(obj[prop]), obj;
              }
              catch(e) {
                return obj[prop];
              }
            }, obj);
          }
          return obj;
        }

        //Detect manipulation of DOM APIs from within the body of the controller
        domInterceptor.addManipulationListener(INTERCEPTOR_FUNCTION);
        var ctrlInstance = $delegate.apply(this, [ctrl, locals]);
        domInterceptor.removeManipulationListener();

        //Detect manipulation of DOM APIs from properties on the controller
        Object.keys(ctrlInstance).forEach(function (prop) {
          if (prop[0] !== '$' && typeof ctrlInstance[prop] === 'function' && !patchedFunctions[prop]) {
            patchedFunctions[prop] = prop;
            ctrlInstance[prop] = disallowedContext(ctrlInstance[prop]);
          }
        });

        //Detect manipulation of DOM APIs from functions defined inside the controller
        if(locals.$scope) {
          Object.keys(locals.$scope).forEach(function (prop) {
            if([prop][0] !== '$' && typeof locals.$scope[prop] === 'function' && !patchedFunctions[prop]) {
              patchedFunctions[prop] = prop;
              locals.$scope[prop] = disallowedContext(locals.$scope[prop]);
            }
          });
        }

        return ctrlInstance;
      };
    });
  });

/**
* Keep a record of 'ControllerName': Controller pairs
* so that a controller can be retrieved via its name
*/
var nameToConstructorMappings = {};
var originalAngularModule = angular.module;
angular.module = function() {
  var module = originalAngularModule.apply(this, arguments);
  var originalController = module.controller;
  module.controller = function(controllerName, controllerConstructor) {
    nameToConstructorMappings[controllerName] = controllerConstructor;
    return originalController.apply(this, arguments);
  };
  return module;
};
